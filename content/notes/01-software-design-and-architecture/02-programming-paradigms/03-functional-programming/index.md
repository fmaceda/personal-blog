---
title: Functional Programming
weight: 203
menu:
  notes:
    name: Functional Programming
    identifier: notes-software-design-and-architecture-programming-paradigms-functional-programming
    parent: notes-software-design-and-architecture-programming-paradigms
    weight: 203
---

{{< note title="Content" >}}

1. Use Intention-Revealing Names
2. Avoid Disinformation
3. Make Meaningful Distinctions
4. Use Pronounceable Names
5. Use Searchable Names
6. Avoid Encodings
7. Avoid Mental Mapping
8. Class Names
9. Method Names
10. Don't Be Cute
11. Pick One Word per Concept
12. Don't Pun
13. Use Solution Domain Names
14. Use Problem Domain Names
15. Don't Add Gratuitous Context
16. Resources

{{< /note >}}

{{< note title="Overview" >}}

The third paradigm, which has only recently begun to be adopted, was the first to be invented. Indeed, its invention predates computer programming itself. Functional programming is the direct result of the work of **Alonzo Church**, who in 1936 invented l-calculus while pursuing the same mathematical problem that was motivating Alan Turing at the same time. His l-calculus is the foundation of the LISP language, invented in 1958 by John McCarthy. A foundational notion of l-calculus is immutabilityâ€”that is, the notion that the values of symbols do not change. This effectively means that a functional language has no assignment statement. Most functional languages do, in fact, have some means to alter the value of a variable, but only under very strict discipline.

We can summarize the functional programming paradigm as follows:

> Functional programming imposes discipline upon assignment.

{{< /note >}}

{{< note title="Resources" >}}

* *Clean Architecture: A Craftsman's Guide to Software Structure and Design*, by Robert C. Martin

{{< /note >}}
